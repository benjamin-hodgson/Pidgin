#region GeneratedCode
using System;

namespace Pidgin;

// Generated by Pidgin.CodeGen.
// Each of these methods is equivalent to
//     return
//         from x1 in p1
//         from x2 in p2
//         ...
//         from xn in pn
//         select func(x1, x2, ..., xn)
// but this lower-level approach saves on allocations
public static partial class Parser
{
    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
    /// </summary>
    /// <param name="func">A function to apply to the return values of the specified parsers</param>
    /// <param name="parser1">The first parser</param>
    /// <param name="parser2">The second parser</param>
    /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
    /// <typeparam name="T1">The return type of the first parser</typeparam>
    /// <typeparam name="T2">The return type of the second parser</typeparam>
    /// <typeparam name="R">The return type of the resulting parser</typeparam>
    public static Parser<TToken, R> Map<TToken, T1, T2, R>(
        Func<T1, T2, R> func,
        Parser<TToken, T1> parser1,
        Parser<TToken, T2> parser2
    )
    {
        if (func == null)
        {
            throw new ArgumentNullException(nameof(func));
        }
        if (parser1 == null)
        {
            throw new ArgumentNullException(nameof(parser1));
        }
        if (parser2 == null)
        {
            throw new ArgumentNullException(nameof(parser2));
        }

        return new Map2ParserFactory1<TToken, T1, T2, R>(func).Unbox(parser1).Unbox(parser2);
    }

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
    /// </summary>
    /// <param name="func">A function to apply to the return values of the specified parsers</param>
    /// <param name="parser1">The first parser</param>
    /// <param name="parser2">The second parser</param>
    /// <param name="parser3">The third parser</param>
    /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
    /// <typeparam name="T1">The return type of the first parser</typeparam>
    /// <typeparam name="T2">The return type of the second parser</typeparam>
    /// <typeparam name="T3">The return type of the third parser</typeparam>
    /// <typeparam name="R">The return type of the resulting parser</typeparam>
    public static Parser<TToken, R> Map<TToken, T1, T2, T3, R>(
        Func<T1, T2, T3, R> func,
        Parser<TToken, T1> parser1,
        Parser<TToken, T2> parser2,
        Parser<TToken, T3> parser3
    )
    {
        if (func == null)
        {
            throw new ArgumentNullException(nameof(func));
        }
        if (parser1 == null)
        {
            throw new ArgumentNullException(nameof(parser1));
        }
        if (parser2 == null)
        {
            throw new ArgumentNullException(nameof(parser2));
        }
        if (parser3 == null)
        {
            throw new ArgumentNullException(nameof(parser3));
        }

        return new Map3ParserFactory1<TToken, T1, T2, T3, R>(func).Unbox(parser1).Unbox(parser2).Unbox(parser3);
    }

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
    /// </summary>
    /// <param name="func">A function to apply to the return values of the specified parsers</param>
    /// <param name="parser1">The first parser</param>
    /// <param name="parser2">The second parser</param>
    /// <param name="parser3">The third parser</param>
    /// <param name="parser4">The fourth parser</param>
    /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
    /// <typeparam name="T1">The return type of the first parser</typeparam>
    /// <typeparam name="T2">The return type of the second parser</typeparam>
    /// <typeparam name="T3">The return type of the third parser</typeparam>
    /// <typeparam name="T4">The return type of the fourth parser</typeparam>
    /// <typeparam name="R">The return type of the resulting parser</typeparam>
    public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, R>(
        Func<T1, T2, T3, T4, R> func,
        Parser<TToken, T1> parser1,
        Parser<TToken, T2> parser2,
        Parser<TToken, T3> parser3,
        Parser<TToken, T4> parser4
    )
    {
        if (func == null)
        {
            throw new ArgumentNullException(nameof(func));
        }
        if (parser1 == null)
        {
            throw new ArgumentNullException(nameof(parser1));
        }
        if (parser2 == null)
        {
            throw new ArgumentNullException(nameof(parser2));
        }
        if (parser3 == null)
        {
            throw new ArgumentNullException(nameof(parser3));
        }
        if (parser4 == null)
        {
            throw new ArgumentNullException(nameof(parser4));
        }

        return new Map4ParserFactory1<TToken, T1, T2, T3, T4, R>(func).Unbox(parser1).Unbox(parser2).Unbox(parser3).Unbox(parser4);
    }

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
    /// </summary>
    /// <param name="func">A function to apply to the return values of the specified parsers</param>
    /// <param name="parser1">The first parser</param>
    /// <param name="parser2">The second parser</param>
    /// <param name="parser3">The third parser</param>
    /// <param name="parser4">The fourth parser</param>
    /// <param name="parser5">The fifth parser</param>
    /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
    /// <typeparam name="T1">The return type of the first parser</typeparam>
    /// <typeparam name="T2">The return type of the second parser</typeparam>
    /// <typeparam name="T3">The return type of the third parser</typeparam>
    /// <typeparam name="T4">The return type of the fourth parser</typeparam>
    /// <typeparam name="T5">The return type of the fifth parser</typeparam>
    /// <typeparam name="R">The return type of the resulting parser</typeparam>
    public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, T5, R>(
        Func<T1, T2, T3, T4, T5, R> func,
        Parser<TToken, T1> parser1,
        Parser<TToken, T2> parser2,
        Parser<TToken, T3> parser3,
        Parser<TToken, T4> parser4,
        Parser<TToken, T5> parser5
    )
    {
        if (func == null)
        {
            throw new ArgumentNullException(nameof(func));
        }
        if (parser1 == null)
        {
            throw new ArgumentNullException(nameof(parser1));
        }
        if (parser2 == null)
        {
            throw new ArgumentNullException(nameof(parser2));
        }
        if (parser3 == null)
        {
            throw new ArgumentNullException(nameof(parser3));
        }
        if (parser4 == null)
        {
            throw new ArgumentNullException(nameof(parser4));
        }
        if (parser5 == null)
        {
            throw new ArgumentNullException(nameof(parser5));
        }

        return new Map5ParserFactory1<TToken, T1, T2, T3, T4, T5, R>(func).Unbox(parser1).Unbox(parser2).Unbox(parser3).Unbox(parser4).Unbox(parser5);
    }

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
    /// </summary>
    /// <param name="func">A function to apply to the return values of the specified parsers</param>
    /// <param name="parser1">The first parser</param>
    /// <param name="parser2">The second parser</param>
    /// <param name="parser3">The third parser</param>
    /// <param name="parser4">The fourth parser</param>
    /// <param name="parser5">The fifth parser</param>
    /// <param name="parser6">The sixth parser</param>
    /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
    /// <typeparam name="T1">The return type of the first parser</typeparam>
    /// <typeparam name="T2">The return type of the second parser</typeparam>
    /// <typeparam name="T3">The return type of the third parser</typeparam>
    /// <typeparam name="T4">The return type of the fourth parser</typeparam>
    /// <typeparam name="T5">The return type of the fifth parser</typeparam>
    /// <typeparam name="T6">The return type of the sixth parser</typeparam>
    /// <typeparam name="R">The return type of the resulting parser</typeparam>
    public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, T5, T6, R>(
        Func<T1, T2, T3, T4, T5, T6, R> func,
        Parser<TToken, T1> parser1,
        Parser<TToken, T2> parser2,
        Parser<TToken, T3> parser3,
        Parser<TToken, T4> parser4,
        Parser<TToken, T5> parser5,
        Parser<TToken, T6> parser6
    )
    {
        if (func == null)
        {
            throw new ArgumentNullException(nameof(func));
        }
        if (parser1 == null)
        {
            throw new ArgumentNullException(nameof(parser1));
        }
        if (parser2 == null)
        {
            throw new ArgumentNullException(nameof(parser2));
        }
        if (parser3 == null)
        {
            throw new ArgumentNullException(nameof(parser3));
        }
        if (parser4 == null)
        {
            throw new ArgumentNullException(nameof(parser4));
        }
        if (parser5 == null)
        {
            throw new ArgumentNullException(nameof(parser5));
        }
        if (parser6 == null)
        {
            throw new ArgumentNullException(nameof(parser6));
        }

        return new Map6ParserFactory1<TToken, T1, T2, T3, T4, T5, T6, R>(func).Unbox(parser1).Unbox(parser2).Unbox(parser3).Unbox(parser4).Unbox(parser5).Unbox(parser6);
    }

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
    /// </summary>
    /// <param name="func">A function to apply to the return values of the specified parsers</param>
    /// <param name="parser1">The first parser</param>
    /// <param name="parser2">The second parser</param>
    /// <param name="parser3">The third parser</param>
    /// <param name="parser4">The fourth parser</param>
    /// <param name="parser5">The fifth parser</param>
    /// <param name="parser6">The sixth parser</param>
    /// <param name="parser7">The seventh parser</param>
    /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
    /// <typeparam name="T1">The return type of the first parser</typeparam>
    /// <typeparam name="T2">The return type of the second parser</typeparam>
    /// <typeparam name="T3">The return type of the third parser</typeparam>
    /// <typeparam name="T4">The return type of the fourth parser</typeparam>
    /// <typeparam name="T5">The return type of the fifth parser</typeparam>
    /// <typeparam name="T6">The return type of the sixth parser</typeparam>
    /// <typeparam name="T7">The return type of the seventh parser</typeparam>
    /// <typeparam name="R">The return type of the resulting parser</typeparam>
    public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, T5, T6, T7, R>(
        Func<T1, T2, T3, T4, T5, T6, T7, R> func,
        Parser<TToken, T1> parser1,
        Parser<TToken, T2> parser2,
        Parser<TToken, T3> parser3,
        Parser<TToken, T4> parser4,
        Parser<TToken, T5> parser5,
        Parser<TToken, T6> parser6,
        Parser<TToken, T7> parser7
    )
    {
        if (func == null)
        {
            throw new ArgumentNullException(nameof(func));
        }
        if (parser1 == null)
        {
            throw new ArgumentNullException(nameof(parser1));
        }
        if (parser2 == null)
        {
            throw new ArgumentNullException(nameof(parser2));
        }
        if (parser3 == null)
        {
            throw new ArgumentNullException(nameof(parser3));
        }
        if (parser4 == null)
        {
            throw new ArgumentNullException(nameof(parser4));
        }
        if (parser5 == null)
        {
            throw new ArgumentNullException(nameof(parser5));
        }
        if (parser6 == null)
        {
            throw new ArgumentNullException(nameof(parser6));
        }
        if (parser7 == null)
        {
            throw new ArgumentNullException(nameof(parser7));
        }

        return new Map7ParserFactory1<TToken, T1, T2, T3, T4, T5, T6, T7, R>(func).Unbox(parser1).Unbox(parser2).Unbox(parser3).Unbox(parser4).Unbox(parser5).Unbox(parser6).Unbox(parser7);
    }

    /// <summary>
    /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
    /// </summary>
    /// <param name="func">A function to apply to the return values of the specified parsers</param>
    /// <param name="parser1">The first parser</param>
    /// <param name="parser2">The second parser</param>
    /// <param name="parser3">The third parser</param>
    /// <param name="parser4">The fourth parser</param>
    /// <param name="parser5">The fifth parser</param>
    /// <param name="parser6">The sixth parser</param>
    /// <param name="parser7">The seventh parser</param>
    /// <param name="parser8">The eighth parser</param>
    /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
    /// <typeparam name="T1">The return type of the first parser</typeparam>
    /// <typeparam name="T2">The return type of the second parser</typeparam>
    /// <typeparam name="T3">The return type of the third parser</typeparam>
    /// <typeparam name="T4">The return type of the fourth parser</typeparam>
    /// <typeparam name="T5">The return type of the fifth parser</typeparam>
    /// <typeparam name="T6">The return type of the sixth parser</typeparam>
    /// <typeparam name="T7">The return type of the seventh parser</typeparam>
    /// <typeparam name="T8">The return type of the eighth parser</typeparam>
    /// <typeparam name="R">The return type of the resulting parser</typeparam>
    public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, T5, T6, T7, T8, R>(
        Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
        Parser<TToken, T1> parser1,
        Parser<TToken, T2> parser2,
        Parser<TToken, T3> parser3,
        Parser<TToken, T4> parser4,
        Parser<TToken, T5> parser5,
        Parser<TToken, T6> parser6,
        Parser<TToken, T7> parser7,
        Parser<TToken, T8> parser8
    )
    {
        if (func == null)
        {
            throw new ArgumentNullException(nameof(func));
        }
        if (parser1 == null)
        {
            throw new ArgumentNullException(nameof(parser1));
        }
        if (parser2 == null)
        {
            throw new ArgumentNullException(nameof(parser2));
        }
        if (parser3 == null)
        {
            throw new ArgumentNullException(nameof(parser3));
        }
        if (parser4 == null)
        {
            throw new ArgumentNullException(nameof(parser4));
        }
        if (parser5 == null)
        {
            throw new ArgumentNullException(nameof(parser5));
        }
        if (parser6 == null)
        {
            throw new ArgumentNullException(nameof(parser6));
        }
        if (parser7 == null)
        {
            throw new ArgumentNullException(nameof(parser7));
        }
        if (parser8 == null)
        {
            throw new ArgumentNullException(nameof(parser8));
        }

        return new Map8ParserFactory1<TToken, T1, T2, T3, T4, T5, T6, T7, T8, R>(func).Unbox(parser1).Unbox(parser2).Unbox(parser3).Unbox(parser4).Unbox(parser5).Unbox(parser6).Unbox(parser7).Unbox(parser8);
    }
}

internal sealed class Map2ParserFactory1<TToken, T1, T2, R>(
    Func<T1, T2, R> func
) : IUnboxer<TToken, T1, IUnboxer<TToken, T2, Parser<TToken, R>>>
    
{
    public IUnboxer<TToken, T2, Parser<TToken, R>> Unbox<Next1>(BoxParser<TToken, T1>.Of<Next1> box)
        where Next1 : IParser<TToken, T1>
        => new Map2ParserFactory2<TToken, T1, T2, Next1, R>(func, box);
}

internal sealed class Map2ParserFactory2<TToken, T1, T2, Next1, R>(
    Func<T1, T2, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1
) : IUnboxer<TToken, T2, Parser<TToken, R>>
    where Next1 : IParser<TToken, T1>
{
    public Parser<TToken, R> Unbox<Next2>(BoxParser<TToken, T2>.Of<Next2> box)
        where Next2 : IParser<TToken, T2>
        => BoxParser<TToken, R>.Create(new Map2Parser<TToken, T1, T2, Next1, Next2, R>(func, parser1, box));
}

internal readonly struct Map2Parser<TToken, T1, T2, Next1, Next2, R> : IMapParser<TToken, R>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
{
    private readonly Func<T1, T2, R> _func;
    private readonly BoxParser<TToken, T1>.Of<Next1> _p1;
    private readonly BoxParser<TToken, T2>.Of<Next2> _p2;

    public Map2Parser(
        Func<T1, T2, R> func,
        BoxParser<TToken, T1>.Of<Next1> parser1,
        BoxParser<TToken, T2>.Of<Next2> parser2
    )
    {
        _func = func;
        _p1 = parser1;
        _p2 = parser2;
    }

    public bool TryParse(ref ParseState<TToken> state, ref PooledList<Expected<TToken>> expecteds, out R result)
    {
        var success1 = _p1.Value.TryParse(ref state, ref expecteds, out var result1);
        if (!success1)
        {
            result = default;
            return false;
        }

        var success2 = _p2.Value.TryParse(ref state, ref expecteds, out var result2);
        if (!success2)
        {
            result = default;
            return false;
        }

        result = _func(
            result1,
            result2
        );
        return true;
    }

    Parser<TToken, U> IMapParser<TToken, R>.MapFast<U>(Func<R, U> func)
    {
        var f = _func;
        return new BoxParser<TToken, U>.Of<Map2Parser<TToken, T1, T2, Next1, Next2, U>>(new(
            (x1, x2) => func(f(x1, x2)),
            _p1,
            _p2
        ));
    }
}

internal sealed class Map3ParserFactory1<TToken, T1, T2, T3, R>(
    Func<T1, T2, T3, R> func
) : IUnboxer<TToken, T1, IUnboxer<TToken, T2, IUnboxer<TToken, T3, Parser<TToken, R>>>>
    
{
    public IUnboxer<TToken, T2, IUnboxer<TToken, T3, Parser<TToken, R>>> Unbox<Next1>(BoxParser<TToken, T1>.Of<Next1> box)
        where Next1 : IParser<TToken, T1>
        => new Map3ParserFactory2<TToken, T1, T2, T3, Next1, R>(func, box);
}

internal sealed class Map3ParserFactory2<TToken, T1, T2, T3, Next1, R>(
    Func<T1, T2, T3, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1
) : IUnboxer<TToken, T2, IUnboxer<TToken, T3, Parser<TToken, R>>>
    where Next1 : IParser<TToken, T1>
{
    public IUnboxer<TToken, T3, Parser<TToken, R>> Unbox<Next2>(BoxParser<TToken, T2>.Of<Next2> box)
        where Next2 : IParser<TToken, T2>
        => new Map3ParserFactory3<TToken, T1, T2, T3, Next1, Next2, R>(func, parser1, box);
}

internal sealed class Map3ParserFactory3<TToken, T1, T2, T3, Next1, Next2, R>(
    Func<T1, T2, T3, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2
) : IUnboxer<TToken, T3, Parser<TToken, R>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
{
    public Parser<TToken, R> Unbox<Next3>(BoxParser<TToken, T3>.Of<Next3> box)
        where Next3 : IParser<TToken, T3>
        => BoxParser<TToken, R>.Create(new Map3Parser<TToken, T1, T2, T3, Next1, Next2, Next3, R>(func, parser1, parser2, box));
}

internal readonly struct Map3Parser<TToken, T1, T2, T3, Next1, Next2, Next3, R> : IMapParser<TToken, R>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
{
    private readonly Func<T1, T2, T3, R> _func;
    private readonly BoxParser<TToken, T1>.Of<Next1> _p1;
    private readonly BoxParser<TToken, T2>.Of<Next2> _p2;
    private readonly BoxParser<TToken, T3>.Of<Next3> _p3;

    public Map3Parser(
        Func<T1, T2, T3, R> func,
        BoxParser<TToken, T1>.Of<Next1> parser1,
        BoxParser<TToken, T2>.Of<Next2> parser2,
        BoxParser<TToken, T3>.Of<Next3> parser3
    )
    {
        _func = func;
        _p1 = parser1;
        _p2 = parser2;
        _p3 = parser3;
    }

    public bool TryParse(ref ParseState<TToken> state, ref PooledList<Expected<TToken>> expecteds, out R result)
    {
        var success1 = _p1.Value.TryParse(ref state, ref expecteds, out var result1);
        if (!success1)
        {
            result = default;
            return false;
        }

        var success2 = _p2.Value.TryParse(ref state, ref expecteds, out var result2);
        if (!success2)
        {
            result = default;
            return false;
        }

        var success3 = _p3.Value.TryParse(ref state, ref expecteds, out var result3);
        if (!success3)
        {
            result = default;
            return false;
        }

        result = _func(
            result1,
            result2,
            result3
        );
        return true;
    }

    Parser<TToken, U> IMapParser<TToken, R>.MapFast<U>(Func<R, U> func)
    {
        var f = _func;
        return new BoxParser<TToken, U>.Of<Map3Parser<TToken, T1, T2, T3, Next1, Next2, Next3, U>>(new(
            (x1, x2, x3) => func(f(x1, x2, x3)),
            _p1,
            _p2,
            _p3
        ));
    }
}

internal sealed class Map4ParserFactory1<TToken, T1, T2, T3, T4, R>(
    Func<T1, T2, T3, T4, R> func
) : IUnboxer<TToken, T1, IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, Parser<TToken, R>>>>>
    
{
    public IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, Parser<TToken, R>>>> Unbox<Next1>(BoxParser<TToken, T1>.Of<Next1> box)
        where Next1 : IParser<TToken, T1>
        => new Map4ParserFactory2<TToken, T1, T2, T3, T4, Next1, R>(func, box);
}

internal sealed class Map4ParserFactory2<TToken, T1, T2, T3, T4, Next1, R>(
    Func<T1, T2, T3, T4, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1
) : IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, Parser<TToken, R>>>>
    where Next1 : IParser<TToken, T1>
{
    public IUnboxer<TToken, T3, IUnboxer<TToken, T4, Parser<TToken, R>>> Unbox<Next2>(BoxParser<TToken, T2>.Of<Next2> box)
        where Next2 : IParser<TToken, T2>
        => new Map4ParserFactory3<TToken, T1, T2, T3, T4, Next1, Next2, R>(func, parser1, box);
}

internal sealed class Map4ParserFactory3<TToken, T1, T2, T3, T4, Next1, Next2, R>(
    Func<T1, T2, T3, T4, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2
) : IUnboxer<TToken, T3, IUnboxer<TToken, T4, Parser<TToken, R>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
{
    public IUnboxer<TToken, T4, Parser<TToken, R>> Unbox<Next3>(BoxParser<TToken, T3>.Of<Next3> box)
        where Next3 : IParser<TToken, T3>
        => new Map4ParserFactory4<TToken, T1, T2, T3, T4, Next1, Next2, Next3, R>(func, parser1, parser2, box);
}

internal sealed class Map4ParserFactory4<TToken, T1, T2, T3, T4, Next1, Next2, Next3, R>(
    Func<T1, T2, T3, T4, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3
) : IUnboxer<TToken, T4, Parser<TToken, R>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
{
    public Parser<TToken, R> Unbox<Next4>(BoxParser<TToken, T4>.Of<Next4> box)
        where Next4 : IParser<TToken, T4>
        => BoxParser<TToken, R>.Create(new Map4Parser<TToken, T1, T2, T3, T4, Next1, Next2, Next3, Next4, R>(func, parser1, parser2, parser3, box));
}

internal readonly struct Map4Parser<TToken, T1, T2, T3, T4, Next1, Next2, Next3, Next4, R> : IMapParser<TToken, R>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
{
    private readonly Func<T1, T2, T3, T4, R> _func;
    private readonly BoxParser<TToken, T1>.Of<Next1> _p1;
    private readonly BoxParser<TToken, T2>.Of<Next2> _p2;
    private readonly BoxParser<TToken, T3>.Of<Next3> _p3;
    private readonly BoxParser<TToken, T4>.Of<Next4> _p4;

    public Map4Parser(
        Func<T1, T2, T3, T4, R> func,
        BoxParser<TToken, T1>.Of<Next1> parser1,
        BoxParser<TToken, T2>.Of<Next2> parser2,
        BoxParser<TToken, T3>.Of<Next3> parser3,
        BoxParser<TToken, T4>.Of<Next4> parser4
    )
    {
        _func = func;
        _p1 = parser1;
        _p2 = parser2;
        _p3 = parser3;
        _p4 = parser4;
    }

    public bool TryParse(ref ParseState<TToken> state, ref PooledList<Expected<TToken>> expecteds, out R result)
    {
        var success1 = _p1.Value.TryParse(ref state, ref expecteds, out var result1);
        if (!success1)
        {
            result = default;
            return false;
        }

        var success2 = _p2.Value.TryParse(ref state, ref expecteds, out var result2);
        if (!success2)
        {
            result = default;
            return false;
        }

        var success3 = _p3.Value.TryParse(ref state, ref expecteds, out var result3);
        if (!success3)
        {
            result = default;
            return false;
        }

        var success4 = _p4.Value.TryParse(ref state, ref expecteds, out var result4);
        if (!success4)
        {
            result = default;
            return false;
        }

        result = _func(
            result1,
            result2,
            result3,
            result4
        );
        return true;
    }

    Parser<TToken, U> IMapParser<TToken, R>.MapFast<U>(Func<R, U> func)
    {
        var f = _func;
        return new BoxParser<TToken, U>.Of<Map4Parser<TToken, T1, T2, T3, T4, Next1, Next2, Next3, Next4, U>>(new(
            (x1, x2, x3, x4) => func(f(x1, x2, x3, x4)),
            _p1,
            _p2,
            _p3,
            _p4
        ));
    }
}

internal sealed class Map5ParserFactory1<TToken, T1, T2, T3, T4, T5, R>(
    Func<T1, T2, T3, T4, T5, R> func
) : IUnboxer<TToken, T1, IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, Parser<TToken, R>>>>>>
    
{
    public IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, Parser<TToken, R>>>>> Unbox<Next1>(BoxParser<TToken, T1>.Of<Next1> box)
        where Next1 : IParser<TToken, T1>
        => new Map5ParserFactory2<TToken, T1, T2, T3, T4, T5, Next1, R>(func, box);
}

internal sealed class Map5ParserFactory2<TToken, T1, T2, T3, T4, T5, Next1, R>(
    Func<T1, T2, T3, T4, T5, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1
) : IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, Parser<TToken, R>>>>>
    where Next1 : IParser<TToken, T1>
{
    public IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, Parser<TToken, R>>>> Unbox<Next2>(BoxParser<TToken, T2>.Of<Next2> box)
        where Next2 : IParser<TToken, T2>
        => new Map5ParserFactory3<TToken, T1, T2, T3, T4, T5, Next1, Next2, R>(func, parser1, box);
}

internal sealed class Map5ParserFactory3<TToken, T1, T2, T3, T4, T5, Next1, Next2, R>(
    Func<T1, T2, T3, T4, T5, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2
) : IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, Parser<TToken, R>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
{
    public IUnboxer<TToken, T4, IUnboxer<TToken, T5, Parser<TToken, R>>> Unbox<Next3>(BoxParser<TToken, T3>.Of<Next3> box)
        where Next3 : IParser<TToken, T3>
        => new Map5ParserFactory4<TToken, T1, T2, T3, T4, T5, Next1, Next2, Next3, R>(func, parser1, parser2, box);
}

internal sealed class Map5ParserFactory4<TToken, T1, T2, T3, T4, T5, Next1, Next2, Next3, R>(
    Func<T1, T2, T3, T4, T5, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3
) : IUnboxer<TToken, T4, IUnboxer<TToken, T5, Parser<TToken, R>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
{
    public IUnboxer<TToken, T5, Parser<TToken, R>> Unbox<Next4>(BoxParser<TToken, T4>.Of<Next4> box)
        where Next4 : IParser<TToken, T4>
        => new Map5ParserFactory5<TToken, T1, T2, T3, T4, T5, Next1, Next2, Next3, Next4, R>(func, parser1, parser2, parser3, box);
}

internal sealed class Map5ParserFactory5<TToken, T1, T2, T3, T4, T5, Next1, Next2, Next3, Next4, R>(
    Func<T1, T2, T3, T4, T5, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4
) : IUnboxer<TToken, T5, Parser<TToken, R>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
{
    public Parser<TToken, R> Unbox<Next5>(BoxParser<TToken, T5>.Of<Next5> box)
        where Next5 : IParser<TToken, T5>
        => BoxParser<TToken, R>.Create(new Map5Parser<TToken, T1, T2, T3, T4, T5, Next1, Next2, Next3, Next4, Next5, R>(func, parser1, parser2, parser3, parser4, box));
}

internal readonly struct Map5Parser<TToken, T1, T2, T3, T4, T5, Next1, Next2, Next3, Next4, Next5, R> : IMapParser<TToken, R>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
{
    private readonly Func<T1, T2, T3, T4, T5, R> _func;
    private readonly BoxParser<TToken, T1>.Of<Next1> _p1;
    private readonly BoxParser<TToken, T2>.Of<Next2> _p2;
    private readonly BoxParser<TToken, T3>.Of<Next3> _p3;
    private readonly BoxParser<TToken, T4>.Of<Next4> _p4;
    private readonly BoxParser<TToken, T5>.Of<Next5> _p5;

    public Map5Parser(
        Func<T1, T2, T3, T4, T5, R> func,
        BoxParser<TToken, T1>.Of<Next1> parser1,
        BoxParser<TToken, T2>.Of<Next2> parser2,
        BoxParser<TToken, T3>.Of<Next3> parser3,
        BoxParser<TToken, T4>.Of<Next4> parser4,
        BoxParser<TToken, T5>.Of<Next5> parser5
    )
    {
        _func = func;
        _p1 = parser1;
        _p2 = parser2;
        _p3 = parser3;
        _p4 = parser4;
        _p5 = parser5;
    }

    public bool TryParse(ref ParseState<TToken> state, ref PooledList<Expected<TToken>> expecteds, out R result)
    {
        var success1 = _p1.Value.TryParse(ref state, ref expecteds, out var result1);
        if (!success1)
        {
            result = default;
            return false;
        }

        var success2 = _p2.Value.TryParse(ref state, ref expecteds, out var result2);
        if (!success2)
        {
            result = default;
            return false;
        }

        var success3 = _p3.Value.TryParse(ref state, ref expecteds, out var result3);
        if (!success3)
        {
            result = default;
            return false;
        }

        var success4 = _p4.Value.TryParse(ref state, ref expecteds, out var result4);
        if (!success4)
        {
            result = default;
            return false;
        }

        var success5 = _p5.Value.TryParse(ref state, ref expecteds, out var result5);
        if (!success5)
        {
            result = default;
            return false;
        }

        result = _func(
            result1,
            result2,
            result3,
            result4,
            result5
        );
        return true;
    }

    Parser<TToken, U> IMapParser<TToken, R>.MapFast<U>(Func<R, U> func)
    {
        var f = _func;
        return new BoxParser<TToken, U>.Of<Map5Parser<TToken, T1, T2, T3, T4, T5, Next1, Next2, Next3, Next4, Next5, U>>(new(
            (x1, x2, x3, x4, x5) => func(f(x1, x2, x3, x4, x5)),
            _p1,
            _p2,
            _p3,
            _p4,
            _p5
        ));
    }
}

internal sealed class Map6ParserFactory1<TToken, T1, T2, T3, T4, T5, T6, R>(
    Func<T1, T2, T3, T4, T5, T6, R> func
) : IUnboxer<TToken, T1, IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, Parser<TToken, R>>>>>>>
    
{
    public IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, Parser<TToken, R>>>>>> Unbox<Next1>(BoxParser<TToken, T1>.Of<Next1> box)
        where Next1 : IParser<TToken, T1>
        => new Map6ParserFactory2<TToken, T1, T2, T3, T4, T5, T6, Next1, R>(func, box);
}

internal sealed class Map6ParserFactory2<TToken, T1, T2, T3, T4, T5, T6, Next1, R>(
    Func<T1, T2, T3, T4, T5, T6, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1
) : IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, Parser<TToken, R>>>>>>
    where Next1 : IParser<TToken, T1>
{
    public IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, Parser<TToken, R>>>>> Unbox<Next2>(BoxParser<TToken, T2>.Of<Next2> box)
        where Next2 : IParser<TToken, T2>
        => new Map6ParserFactory3<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, R>(func, parser1, box);
}

internal sealed class Map6ParserFactory3<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, R>(
    Func<T1, T2, T3, T4, T5, T6, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2
) : IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, Parser<TToken, R>>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
{
    public IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, Parser<TToken, R>>>> Unbox<Next3>(BoxParser<TToken, T3>.Of<Next3> box)
        where Next3 : IParser<TToken, T3>
        => new Map6ParserFactory4<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, Next3, R>(func, parser1, parser2, box);
}

internal sealed class Map6ParserFactory4<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, Next3, R>(
    Func<T1, T2, T3, T4, T5, T6, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3
) : IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, Parser<TToken, R>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
{
    public IUnboxer<TToken, T5, IUnboxer<TToken, T6, Parser<TToken, R>>> Unbox<Next4>(BoxParser<TToken, T4>.Of<Next4> box)
        where Next4 : IParser<TToken, T4>
        => new Map6ParserFactory5<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, Next3, Next4, R>(func, parser1, parser2, parser3, box);
}

internal sealed class Map6ParserFactory5<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, Next3, Next4, R>(
    Func<T1, T2, T3, T4, T5, T6, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4
) : IUnboxer<TToken, T5, IUnboxer<TToken, T6, Parser<TToken, R>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
{
    public IUnboxer<TToken, T6, Parser<TToken, R>> Unbox<Next5>(BoxParser<TToken, T5>.Of<Next5> box)
        where Next5 : IParser<TToken, T5>
        => new Map6ParserFactory6<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, Next3, Next4, Next5, R>(func, parser1, parser2, parser3, parser4, box);
}

internal sealed class Map6ParserFactory6<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, Next3, Next4, Next5, R>(
    Func<T1, T2, T3, T4, T5, T6, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4,
    BoxParser<TToken, T5>.Of<Next5> parser5
) : IUnboxer<TToken, T6, Parser<TToken, R>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
{
    public Parser<TToken, R> Unbox<Next6>(BoxParser<TToken, T6>.Of<Next6> box)
        where Next6 : IParser<TToken, T6>
        => BoxParser<TToken, R>.Create(new Map6Parser<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, Next3, Next4, Next5, Next6, R>(func, parser1, parser2, parser3, parser4, parser5, box));
}

internal readonly struct Map6Parser<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, Next3, Next4, Next5, Next6, R> : IMapParser<TToken, R>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
    where Next6 : IParser<TToken, T6>
{
    private readonly Func<T1, T2, T3, T4, T5, T6, R> _func;
    private readonly BoxParser<TToken, T1>.Of<Next1> _p1;
    private readonly BoxParser<TToken, T2>.Of<Next2> _p2;
    private readonly BoxParser<TToken, T3>.Of<Next3> _p3;
    private readonly BoxParser<TToken, T4>.Of<Next4> _p4;
    private readonly BoxParser<TToken, T5>.Of<Next5> _p5;
    private readonly BoxParser<TToken, T6>.Of<Next6> _p6;

    public Map6Parser(
        Func<T1, T2, T3, T4, T5, T6, R> func,
        BoxParser<TToken, T1>.Of<Next1> parser1,
        BoxParser<TToken, T2>.Of<Next2> parser2,
        BoxParser<TToken, T3>.Of<Next3> parser3,
        BoxParser<TToken, T4>.Of<Next4> parser4,
        BoxParser<TToken, T5>.Of<Next5> parser5,
        BoxParser<TToken, T6>.Of<Next6> parser6
    )
    {
        _func = func;
        _p1 = parser1;
        _p2 = parser2;
        _p3 = parser3;
        _p4 = parser4;
        _p5 = parser5;
        _p6 = parser6;
    }

    public bool TryParse(ref ParseState<TToken> state, ref PooledList<Expected<TToken>> expecteds, out R result)
    {
        var success1 = _p1.Value.TryParse(ref state, ref expecteds, out var result1);
        if (!success1)
        {
            result = default;
            return false;
        }

        var success2 = _p2.Value.TryParse(ref state, ref expecteds, out var result2);
        if (!success2)
        {
            result = default;
            return false;
        }

        var success3 = _p3.Value.TryParse(ref state, ref expecteds, out var result3);
        if (!success3)
        {
            result = default;
            return false;
        }

        var success4 = _p4.Value.TryParse(ref state, ref expecteds, out var result4);
        if (!success4)
        {
            result = default;
            return false;
        }

        var success5 = _p5.Value.TryParse(ref state, ref expecteds, out var result5);
        if (!success5)
        {
            result = default;
            return false;
        }

        var success6 = _p6.Value.TryParse(ref state, ref expecteds, out var result6);
        if (!success6)
        {
            result = default;
            return false;
        }

        result = _func(
            result1,
            result2,
            result3,
            result4,
            result5,
            result6
        );
        return true;
    }

    Parser<TToken, U> IMapParser<TToken, R>.MapFast<U>(Func<R, U> func)
    {
        var f = _func;
        return new BoxParser<TToken, U>.Of<Map6Parser<TToken, T1, T2, T3, T4, T5, T6, Next1, Next2, Next3, Next4, Next5, Next6, U>>(new(
            (x1, x2, x3, x4, x5, x6) => func(f(x1, x2, x3, x4, x5, x6)),
            _p1,
            _p2,
            _p3,
            _p4,
            _p5,
            _p6
        ));
    }
}

internal sealed class Map7ParserFactory1<TToken, T1, T2, T3, T4, T5, T6, T7, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, R> func
) : IUnboxer<TToken, T1, IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>>>>>>
    
{
    public IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>>>>> Unbox<Next1>(BoxParser<TToken, T1>.Of<Next1> box)
        where Next1 : IParser<TToken, T1>
        => new Map7ParserFactory2<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, R>(func, box);
}

internal sealed class Map7ParserFactory2<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1
) : IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>>>>>
    where Next1 : IParser<TToken, T1>
{
    public IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>>>> Unbox<Next2>(BoxParser<TToken, T2>.Of<Next2> box)
        where Next2 : IParser<TToken, T2>
        => new Map7ParserFactory3<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, R>(func, parser1, box);
}

internal sealed class Map7ParserFactory3<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2
) : IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
{
    public IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>>> Unbox<Next3>(BoxParser<TToken, T3>.Of<Next3> box)
        where Next3 : IParser<TToken, T3>
        => new Map7ParserFactory4<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, R>(func, parser1, parser2, box);
}

internal sealed class Map7ParserFactory4<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3
) : IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
{
    public IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>> Unbox<Next4>(BoxParser<TToken, T4>.Of<Next4> box)
        where Next4 : IParser<TToken, T4>
        => new Map7ParserFactory5<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, Next4, R>(func, parser1, parser2, parser3, box);
}

internal sealed class Map7ParserFactory5<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, Next4, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4
) : IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
{
    public IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>> Unbox<Next5>(BoxParser<TToken, T5>.Of<Next5> box)
        where Next5 : IParser<TToken, T5>
        => new Map7ParserFactory6<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, Next4, Next5, R>(func, parser1, parser2, parser3, parser4, box);
}

internal sealed class Map7ParserFactory6<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, Next4, Next5, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4,
    BoxParser<TToken, T5>.Of<Next5> parser5
) : IUnboxer<TToken, T6, IUnboxer<TToken, T7, Parser<TToken, R>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
{
    public IUnboxer<TToken, T7, Parser<TToken, R>> Unbox<Next6>(BoxParser<TToken, T6>.Of<Next6> box)
        where Next6 : IParser<TToken, T6>
        => new Map7ParserFactory7<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, Next4, Next5, Next6, R>(func, parser1, parser2, parser3, parser4, parser5, box);
}

internal sealed class Map7ParserFactory7<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, Next4, Next5, Next6, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4,
    BoxParser<TToken, T5>.Of<Next5> parser5,
    BoxParser<TToken, T6>.Of<Next6> parser6
) : IUnboxer<TToken, T7, Parser<TToken, R>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
    where Next6 : IParser<TToken, T6>
{
    public Parser<TToken, R> Unbox<Next7>(BoxParser<TToken, T7>.Of<Next7> box)
        where Next7 : IParser<TToken, T7>
        => BoxParser<TToken, R>.Create(new Map7Parser<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, Next4, Next5, Next6, Next7, R>(func, parser1, parser2, parser3, parser4, parser5, parser6, box));
}

internal readonly struct Map7Parser<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, Next4, Next5, Next6, Next7, R> : IMapParser<TToken, R>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
    where Next6 : IParser<TToken, T6>
    where Next7 : IParser<TToken, T7>
{
    private readonly Func<T1, T2, T3, T4, T5, T6, T7, R> _func;
    private readonly BoxParser<TToken, T1>.Of<Next1> _p1;
    private readonly BoxParser<TToken, T2>.Of<Next2> _p2;
    private readonly BoxParser<TToken, T3>.Of<Next3> _p3;
    private readonly BoxParser<TToken, T4>.Of<Next4> _p4;
    private readonly BoxParser<TToken, T5>.Of<Next5> _p5;
    private readonly BoxParser<TToken, T6>.Of<Next6> _p6;
    private readonly BoxParser<TToken, T7>.Of<Next7> _p7;

    public Map7Parser(
        Func<T1, T2, T3, T4, T5, T6, T7, R> func,
        BoxParser<TToken, T1>.Of<Next1> parser1,
        BoxParser<TToken, T2>.Of<Next2> parser2,
        BoxParser<TToken, T3>.Of<Next3> parser3,
        BoxParser<TToken, T4>.Of<Next4> parser4,
        BoxParser<TToken, T5>.Of<Next5> parser5,
        BoxParser<TToken, T6>.Of<Next6> parser6,
        BoxParser<TToken, T7>.Of<Next7> parser7
    )
    {
        _func = func;
        _p1 = parser1;
        _p2 = parser2;
        _p3 = parser3;
        _p4 = parser4;
        _p5 = parser5;
        _p6 = parser6;
        _p7 = parser7;
    }

    public bool TryParse(ref ParseState<TToken> state, ref PooledList<Expected<TToken>> expecteds, out R result)
    {
        var success1 = _p1.Value.TryParse(ref state, ref expecteds, out var result1);
        if (!success1)
        {
            result = default;
            return false;
        }

        var success2 = _p2.Value.TryParse(ref state, ref expecteds, out var result2);
        if (!success2)
        {
            result = default;
            return false;
        }

        var success3 = _p3.Value.TryParse(ref state, ref expecteds, out var result3);
        if (!success3)
        {
            result = default;
            return false;
        }

        var success4 = _p4.Value.TryParse(ref state, ref expecteds, out var result4);
        if (!success4)
        {
            result = default;
            return false;
        }

        var success5 = _p5.Value.TryParse(ref state, ref expecteds, out var result5);
        if (!success5)
        {
            result = default;
            return false;
        }

        var success6 = _p6.Value.TryParse(ref state, ref expecteds, out var result6);
        if (!success6)
        {
            result = default;
            return false;
        }

        var success7 = _p7.Value.TryParse(ref state, ref expecteds, out var result7);
        if (!success7)
        {
            result = default;
            return false;
        }

        result = _func(
            result1,
            result2,
            result3,
            result4,
            result5,
            result6,
            result7
        );
        return true;
    }

    Parser<TToken, U> IMapParser<TToken, R>.MapFast<U>(Func<R, U> func)
    {
        var f = _func;
        return new BoxParser<TToken, U>.Of<Map7Parser<TToken, T1, T2, T3, T4, T5, T6, T7, Next1, Next2, Next3, Next4, Next5, Next6, Next7, U>>(new(
            (x1, x2, x3, x4, x5, x6, x7) => func(f(x1, x2, x3, x4, x5, x6, x7)),
            _p1,
            _p2,
            _p3,
            _p4,
            _p5,
            _p6,
            _p7
        ));
    }
}

internal sealed class Map8ParserFactory1<TToken, T1, T2, T3, T4, T5, T6, T7, T8, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func
) : IUnboxer<TToken, T1, IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>>>>>>
    
{
    public IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>>>>> Unbox<Next1>(BoxParser<TToken, T1>.Of<Next1> box)
        where Next1 : IParser<TToken, T1>
        => new Map8ParserFactory2<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, R>(func, box);
}

internal sealed class Map8ParserFactory2<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1
) : IUnboxer<TToken, T2, IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>>>>>
    where Next1 : IParser<TToken, T1>
{
    public IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>>>> Unbox<Next2>(BoxParser<TToken, T2>.Of<Next2> box)
        where Next2 : IParser<TToken, T2>
        => new Map8ParserFactory3<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, R>(func, parser1, box);
}

internal sealed class Map8ParserFactory3<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2
) : IUnboxer<TToken, T3, IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
{
    public IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>>> Unbox<Next3>(BoxParser<TToken, T3>.Of<Next3> box)
        where Next3 : IParser<TToken, T3>
        => new Map8ParserFactory4<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, R>(func, parser1, parser2, box);
}

internal sealed class Map8ParserFactory4<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3
) : IUnboxer<TToken, T4, IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
{
    public IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>> Unbox<Next4>(BoxParser<TToken, T4>.Of<Next4> box)
        where Next4 : IParser<TToken, T4>
        => new Map8ParserFactory5<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, R>(func, parser1, parser2, parser3, box);
}

internal sealed class Map8ParserFactory5<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4
) : IUnboxer<TToken, T5, IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
{
    public IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>> Unbox<Next5>(BoxParser<TToken, T5>.Of<Next5> box)
        where Next5 : IParser<TToken, T5>
        => new Map8ParserFactory6<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, Next5, R>(func, parser1, parser2, parser3, parser4, box);
}

internal sealed class Map8ParserFactory6<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, Next5, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4,
    BoxParser<TToken, T5>.Of<Next5> parser5
) : IUnboxer<TToken, T6, IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
{
    public IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>> Unbox<Next6>(BoxParser<TToken, T6>.Of<Next6> box)
        where Next6 : IParser<TToken, T6>
        => new Map8ParserFactory7<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, Next5, Next6, R>(func, parser1, parser2, parser3, parser4, parser5, box);
}

internal sealed class Map8ParserFactory7<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, Next5, Next6, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4,
    BoxParser<TToken, T5>.Of<Next5> parser5,
    BoxParser<TToken, T6>.Of<Next6> parser6
) : IUnboxer<TToken, T7, IUnboxer<TToken, T8, Parser<TToken, R>>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
    where Next6 : IParser<TToken, T6>
{
    public IUnboxer<TToken, T8, Parser<TToken, R>> Unbox<Next7>(BoxParser<TToken, T7>.Of<Next7> box)
        where Next7 : IParser<TToken, T7>
        => new Map8ParserFactory8<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, Next5, Next6, Next7, R>(func, parser1, parser2, parser3, parser4, parser5, parser6, box);
}

internal sealed class Map8ParserFactory8<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, Next5, Next6, Next7, R>(
    Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
    BoxParser<TToken, T1>.Of<Next1> parser1,
    BoxParser<TToken, T2>.Of<Next2> parser2,
    BoxParser<TToken, T3>.Of<Next3> parser3,
    BoxParser<TToken, T4>.Of<Next4> parser4,
    BoxParser<TToken, T5>.Of<Next5> parser5,
    BoxParser<TToken, T6>.Of<Next6> parser6,
    BoxParser<TToken, T7>.Of<Next7> parser7
) : IUnboxer<TToken, T8, Parser<TToken, R>>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
    where Next6 : IParser<TToken, T6>
    where Next7 : IParser<TToken, T7>
{
    public Parser<TToken, R> Unbox<Next8>(BoxParser<TToken, T8>.Of<Next8> box)
        where Next8 : IParser<TToken, T8>
        => BoxParser<TToken, R>.Create(new Map8Parser<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, Next5, Next6, Next7, Next8, R>(func, parser1, parser2, parser3, parser4, parser5, parser6, parser7, box));
}

internal readonly struct Map8Parser<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, Next5, Next6, Next7, Next8, R> : IMapParser<TToken, R>
    where Next1 : IParser<TToken, T1>
    where Next2 : IParser<TToken, T2>
    where Next3 : IParser<TToken, T3>
    where Next4 : IParser<TToken, T4>
    where Next5 : IParser<TToken, T5>
    where Next6 : IParser<TToken, T6>
    where Next7 : IParser<TToken, T7>
    where Next8 : IParser<TToken, T8>
{
    private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, R> _func;
    private readonly BoxParser<TToken, T1>.Of<Next1> _p1;
    private readonly BoxParser<TToken, T2>.Of<Next2> _p2;
    private readonly BoxParser<TToken, T3>.Of<Next3> _p3;
    private readonly BoxParser<TToken, T4>.Of<Next4> _p4;
    private readonly BoxParser<TToken, T5>.Of<Next5> _p5;
    private readonly BoxParser<TToken, T6>.Of<Next6> _p6;
    private readonly BoxParser<TToken, T7>.Of<Next7> _p7;
    private readonly BoxParser<TToken, T8>.Of<Next8> _p8;

    public Map8Parser(
        Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
        BoxParser<TToken, T1>.Of<Next1> parser1,
        BoxParser<TToken, T2>.Of<Next2> parser2,
        BoxParser<TToken, T3>.Of<Next3> parser3,
        BoxParser<TToken, T4>.Of<Next4> parser4,
        BoxParser<TToken, T5>.Of<Next5> parser5,
        BoxParser<TToken, T6>.Of<Next6> parser6,
        BoxParser<TToken, T7>.Of<Next7> parser7,
        BoxParser<TToken, T8>.Of<Next8> parser8
    )
    {
        _func = func;
        _p1 = parser1;
        _p2 = parser2;
        _p3 = parser3;
        _p4 = parser4;
        _p5 = parser5;
        _p6 = parser6;
        _p7 = parser7;
        _p8 = parser8;
    }

    public bool TryParse(ref ParseState<TToken> state, ref PooledList<Expected<TToken>> expecteds, out R result)
    {
        var success1 = _p1.Value.TryParse(ref state, ref expecteds, out var result1);
        if (!success1)
        {
            result = default;
            return false;
        }

        var success2 = _p2.Value.TryParse(ref state, ref expecteds, out var result2);
        if (!success2)
        {
            result = default;
            return false;
        }

        var success3 = _p3.Value.TryParse(ref state, ref expecteds, out var result3);
        if (!success3)
        {
            result = default;
            return false;
        }

        var success4 = _p4.Value.TryParse(ref state, ref expecteds, out var result4);
        if (!success4)
        {
            result = default;
            return false;
        }

        var success5 = _p5.Value.TryParse(ref state, ref expecteds, out var result5);
        if (!success5)
        {
            result = default;
            return false;
        }

        var success6 = _p6.Value.TryParse(ref state, ref expecteds, out var result6);
        if (!success6)
        {
            result = default;
            return false;
        }

        var success7 = _p7.Value.TryParse(ref state, ref expecteds, out var result7);
        if (!success7)
        {
            result = default;
            return false;
        }

        var success8 = _p8.Value.TryParse(ref state, ref expecteds, out var result8);
        if (!success8)
        {
            result = default;
            return false;
        }

        result = _func(
            result1,
            result2,
            result3,
            result4,
            result5,
            result6,
            result7,
            result8
        );
        return true;
    }

    Parser<TToken, U> IMapParser<TToken, R>.MapFast<U>(Func<R, U> func)
    {
        var f = _func;
        return new BoxParser<TToken, U>.Of<Map8Parser<TToken, T1, T2, T3, T4, T5, T6, T7, T8, Next1, Next2, Next3, Next4, Next5, Next6, Next7, Next8, U>>(new(
            (x1, x2, x3, x4, x5, x6, x7, x8) => func(f(x1, x2, x3, x4, x5, x6, x7, x8)),
            _p1,
            _p2,
            _p3,
            _p4,
            _p5,
            _p6,
            _p7,
            _p8
        ));
    }
}
#endregion
