using System;
using Pidgin.ParseStates;

namespace Pidgin
{
    // Generated by Pidgin.CodeGen.
    // Each of these methods is equivalent to
    //     return
    //         from x1 in p1
    //         from x2 in p2
    //         ...
    //         from xn in pn
    //         select func(x1, x2, ..., xn)
    // but this lower-level approach saves on allocations
    public static partial class Parser
    {
#region GeneratedCode
        
        /// <summary>
        /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
        /// </summary>
        /// <param name="func">A function to apply to the return values of the specified parsers</param>
        /// <param name="parser1">The first parser</param>
        /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
        /// <typeparam name="T1">The return type of the first parser</typeparam>
        /// <typeparam name="R">The return type of the resulting parser</typeparam>
        public static Parser<TToken, R> Map<TToken, T1, R>(
            Func<T1, R> func,
            Parser<TToken, T1> parser1
        ) => new Map1Parser<TToken, T1, R>(func, parser1);
        
        private sealed class Map1Parser<TToken, T1, R> : Parser<TToken, R>
        {
            private readonly Func<T1, R> _func;
            private readonly Parser<TToken, T1> _p1;

            public Map1Parser(
                Func<T1, R> func,
                Parser<TToken, T1> parser1
            ) : base(ExpectedUtil.Concat(parser1.Expected))
            {
                _func = func;
                _p1 = parser1;
            }

            internal sealed override Result<TToken, R> Parse(IParseState<TToken> state)
            {
                var consumedInput = false;

                
                var result1 = _p1.Parse(state);
                consumedInput = consumedInput || result1.ConsumedInput;
                if (!result1.Success)
                {
                    return Result.Failure<TToken, R>(
                        result1.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                return Result.Success<TToken, R>(_func(
                    result1.GetValueOrDefault()
                ), consumedInput);
            }
        }

        /// <summary>
        /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
        /// </summary>
        /// <param name="func">A function to apply to the return values of the specified parsers</param>
        /// <param name="parser1">The first parser</param>
        /// <param name="parser2">The second parser</param>
        /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
        /// <typeparam name="T1">The return type of the first parser</typeparam>
        ///<typeparam name="T2">The return type of the second parser</typeparam>
        /// <typeparam name="R">The return type of the resulting parser</typeparam>
        public static Parser<TToken, R> Map<TToken, T1, T2, R>(
            Func<T1, T2, R> func,
            Parser<TToken, T1> parser1,
            Parser<TToken, T2> parser2
        ) => new Map2Parser<TToken, T1, T2, R>(func, parser1, parser2);
        
        private sealed class Map2Parser<TToken, T1, T2, R> : Parser<TToken, R>
        {
            private readonly Func<T1, T2, R> _func;
            private readonly Parser<TToken, T1> _p1;
            private readonly Parser<TToken, T2> _p2;

            public Map2Parser(
                Func<T1, T2, R> func,
                Parser<TToken, T1> parser1,
                Parser<TToken, T2> parser2
            ) : base(ExpectedUtil.Concat(parser1.Expected, parser2.Expected))
            {
                _func = func;
                _p1 = parser1;
                _p2 = parser2;
            }

            internal sealed override Result<TToken, R> Parse(IParseState<TToken> state)
            {
                var consumedInput = false;

                
                var result1 = _p1.Parse(state);
                consumedInput = consumedInput || result1.ConsumedInput;
                if (!result1.Success)
                {
                    return Result.Failure<TToken, R>(
                        result1.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result2 = _p2.Parse(state);
                consumedInput = consumedInput || result2.ConsumedInput;
                if (!result2.Success)
                {
                    return Result.Failure<TToken, R>(
                        result2.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                return Result.Success<TToken, R>(_func(
                    result1.GetValueOrDefault(),
                    result2.GetValueOrDefault()
                ), consumedInput);
            }
        }

        /// <summary>
        /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
        /// </summary>
        /// <param name="func">A function to apply to the return values of the specified parsers</param>
        /// <param name="parser1">The first parser</param>
        /// <param name="parser2">The second parser</param>
        /// <param name="parser3">The third parser</param>
        /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
        /// <typeparam name="T1">The return type of the first parser</typeparam>
        ///<typeparam name="T2">The return type of the second parser</typeparam>
        ///<typeparam name="T3">The return type of the third parser</typeparam>
        /// <typeparam name="R">The return type of the resulting parser</typeparam>
        public static Parser<TToken, R> Map<TToken, T1, T2, T3, R>(
            Func<T1, T2, T3, R> func,
            Parser<TToken, T1> parser1,
            Parser<TToken, T2> parser2,
            Parser<TToken, T3> parser3
        ) => new Map3Parser<TToken, T1, T2, T3, R>(func, parser1, parser2, parser3);
        
        private sealed class Map3Parser<TToken, T1, T2, T3, R> : Parser<TToken, R>
        {
            private readonly Func<T1, T2, T3, R> _func;
            private readonly Parser<TToken, T1> _p1;
            private readonly Parser<TToken, T2> _p2;
            private readonly Parser<TToken, T3> _p3;

            public Map3Parser(
                Func<T1, T2, T3, R> func,
                Parser<TToken, T1> parser1,
                Parser<TToken, T2> parser2,
                Parser<TToken, T3> parser3
            ) : base(ExpectedUtil.Concat(parser1.Expected, parser2.Expected, parser3.Expected))
            {
                _func = func;
                _p1 = parser1;
                _p2 = parser2;
                _p3 = parser3;
            }

            internal sealed override Result<TToken, R> Parse(IParseState<TToken> state)
            {
                var consumedInput = false;

                
                var result1 = _p1.Parse(state);
                consumedInput = consumedInput || result1.ConsumedInput;
                if (!result1.Success)
                {
                    return Result.Failure<TToken, R>(
                        result1.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result2 = _p2.Parse(state);
                consumedInput = consumedInput || result2.ConsumedInput;
                if (!result2.Success)
                {
                    return Result.Failure<TToken, R>(
                        result2.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result3 = _p3.Parse(state);
                consumedInput = consumedInput || result3.ConsumedInput;
                if (!result3.Success)
                {
                    return Result.Failure<TToken, R>(
                        result3.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                return Result.Success<TToken, R>(_func(
                    result1.GetValueOrDefault(),
                    result2.GetValueOrDefault(),
                    result3.GetValueOrDefault()
                ), consumedInput);
            }
        }

        /// <summary>
        /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
        /// </summary>
        /// <param name="func">A function to apply to the return values of the specified parsers</param>
        /// <param name="parser1">The first parser</param>
        /// <param name="parser2">The second parser</param>
        /// <param name="parser3">The third parser</param>
        /// <param name="parser4">The fourth parser</param>
        /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
        /// <typeparam name="T1">The return type of the first parser</typeparam>
        ///<typeparam name="T2">The return type of the second parser</typeparam>
        ///<typeparam name="T3">The return type of the third parser</typeparam>
        ///<typeparam name="T4">The return type of the fourth parser</typeparam>
        /// <typeparam name="R">The return type of the resulting parser</typeparam>
        public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, R>(
            Func<T1, T2, T3, T4, R> func,
            Parser<TToken, T1> parser1,
            Parser<TToken, T2> parser2,
            Parser<TToken, T3> parser3,
            Parser<TToken, T4> parser4
        ) => new Map4Parser<TToken, T1, T2, T3, T4, R>(func, parser1, parser2, parser3, parser4);
        
        private sealed class Map4Parser<TToken, T1, T2, T3, T4, R> : Parser<TToken, R>
        {
            private readonly Func<T1, T2, T3, T4, R> _func;
            private readonly Parser<TToken, T1> _p1;
            private readonly Parser<TToken, T2> _p2;
            private readonly Parser<TToken, T3> _p3;
            private readonly Parser<TToken, T4> _p4;

            public Map4Parser(
                Func<T1, T2, T3, T4, R> func,
                Parser<TToken, T1> parser1,
                Parser<TToken, T2> parser2,
                Parser<TToken, T3> parser3,
                Parser<TToken, T4> parser4
            ) : base(ExpectedUtil.Concat(parser1.Expected, parser2.Expected, parser3.Expected, parser4.Expected))
            {
                _func = func;
                _p1 = parser1;
                _p2 = parser2;
                _p3 = parser3;
                _p4 = parser4;
            }

            internal sealed override Result<TToken, R> Parse(IParseState<TToken> state)
            {
                var consumedInput = false;

                
                var result1 = _p1.Parse(state);
                consumedInput = consumedInput || result1.ConsumedInput;
                if (!result1.Success)
                {
                    return Result.Failure<TToken, R>(
                        result1.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result2 = _p2.Parse(state);
                consumedInput = consumedInput || result2.ConsumedInput;
                if (!result2.Success)
                {
                    return Result.Failure<TToken, R>(
                        result2.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result3 = _p3.Parse(state);
                consumedInput = consumedInput || result3.ConsumedInput;
                if (!result3.Success)
                {
                    return Result.Failure<TToken, R>(
                        result3.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result4 = _p4.Parse(state);
                consumedInput = consumedInput || result4.ConsumedInput;
                if (!result4.Success)
                {
                    return Result.Failure<TToken, R>(
                        result4.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                return Result.Success<TToken, R>(_func(
                    result1.GetValueOrDefault(),
                    result2.GetValueOrDefault(),
                    result3.GetValueOrDefault(),
                    result4.GetValueOrDefault()
                ), consumedInput);
            }
        }

        /// <summary>
        /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
        /// </summary>
        /// <param name="func">A function to apply to the return values of the specified parsers</param>
        /// <param name="parser1">The first parser</param>
        /// <param name="parser2">The second parser</param>
        /// <param name="parser3">The third parser</param>
        /// <param name="parser4">The fourth parser</param>
        /// <param name="parser5">The fifth parser</param>
        /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
        /// <typeparam name="T1">The return type of the first parser</typeparam>
        ///<typeparam name="T2">The return type of the second parser</typeparam>
        ///<typeparam name="T3">The return type of the third parser</typeparam>
        ///<typeparam name="T4">The return type of the fourth parser</typeparam>
        ///<typeparam name="T5">The return type of the fifth parser</typeparam>
        /// <typeparam name="R">The return type of the resulting parser</typeparam>
        public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, T5, R>(
            Func<T1, T2, T3, T4, T5, R> func,
            Parser<TToken, T1> parser1,
            Parser<TToken, T2> parser2,
            Parser<TToken, T3> parser3,
            Parser<TToken, T4> parser4,
            Parser<TToken, T5> parser5
        ) => new Map5Parser<TToken, T1, T2, T3, T4, T5, R>(func, parser1, parser2, parser3, parser4, parser5);
        
        private sealed class Map5Parser<TToken, T1, T2, T3, T4, T5, R> : Parser<TToken, R>
        {
            private readonly Func<T1, T2, T3, T4, T5, R> _func;
            private readonly Parser<TToken, T1> _p1;
            private readonly Parser<TToken, T2> _p2;
            private readonly Parser<TToken, T3> _p3;
            private readonly Parser<TToken, T4> _p4;
            private readonly Parser<TToken, T5> _p5;

            public Map5Parser(
                Func<T1, T2, T3, T4, T5, R> func,
                Parser<TToken, T1> parser1,
                Parser<TToken, T2> parser2,
                Parser<TToken, T3> parser3,
                Parser<TToken, T4> parser4,
                Parser<TToken, T5> parser5
            ) : base(ExpectedUtil.Concat(parser1.Expected, parser2.Expected, parser3.Expected, parser4.Expected, parser5.Expected))
            {
                _func = func;
                _p1 = parser1;
                _p2 = parser2;
                _p3 = parser3;
                _p4 = parser4;
                _p5 = parser5;
            }

            internal sealed override Result<TToken, R> Parse(IParseState<TToken> state)
            {
                var consumedInput = false;

                
                var result1 = _p1.Parse(state);
                consumedInput = consumedInput || result1.ConsumedInput;
                if (!result1.Success)
                {
                    return Result.Failure<TToken, R>(
                        result1.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result2 = _p2.Parse(state);
                consumedInput = consumedInput || result2.ConsumedInput;
                if (!result2.Success)
                {
                    return Result.Failure<TToken, R>(
                        result2.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result3 = _p3.Parse(state);
                consumedInput = consumedInput || result3.ConsumedInput;
                if (!result3.Success)
                {
                    return Result.Failure<TToken, R>(
                        result3.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result4 = _p4.Parse(state);
                consumedInput = consumedInput || result4.ConsumedInput;
                if (!result4.Success)
                {
                    return Result.Failure<TToken, R>(
                        result4.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result5 = _p5.Parse(state);
                consumedInput = consumedInput || result5.ConsumedInput;
                if (!result5.Success)
                {
                    return Result.Failure<TToken, R>(
                        result5.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                return Result.Success<TToken, R>(_func(
                    result1.GetValueOrDefault(),
                    result2.GetValueOrDefault(),
                    result3.GetValueOrDefault(),
                    result4.GetValueOrDefault(),
                    result5.GetValueOrDefault()
                ), consumedInput);
            }
        }

        /// <summary>
        /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
        /// </summary>
        /// <param name="func">A function to apply to the return values of the specified parsers</param>
        /// <param name="parser1">The first parser</param>
        /// <param name="parser2">The second parser</param>
        /// <param name="parser3">The third parser</param>
        /// <param name="parser4">The fourth parser</param>
        /// <param name="parser5">The fifth parser</param>
        /// <param name="parser6">The sixth parser</param>
        /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
        /// <typeparam name="T1">The return type of the first parser</typeparam>
        ///<typeparam name="T2">The return type of the second parser</typeparam>
        ///<typeparam name="T3">The return type of the third parser</typeparam>
        ///<typeparam name="T4">The return type of the fourth parser</typeparam>
        ///<typeparam name="T5">The return type of the fifth parser</typeparam>
        ///<typeparam name="T6">The return type of the sixth parser</typeparam>
        /// <typeparam name="R">The return type of the resulting parser</typeparam>
        public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, T5, T6, R>(
            Func<T1, T2, T3, T4, T5, T6, R> func,
            Parser<TToken, T1> parser1,
            Parser<TToken, T2> parser2,
            Parser<TToken, T3> parser3,
            Parser<TToken, T4> parser4,
            Parser<TToken, T5> parser5,
            Parser<TToken, T6> parser6
        ) => new Map6Parser<TToken, T1, T2, T3, T4, T5, T6, R>(func, parser1, parser2, parser3, parser4, parser5, parser6);
        
        private sealed class Map6Parser<TToken, T1, T2, T3, T4, T5, T6, R> : Parser<TToken, R>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, R> _func;
            private readonly Parser<TToken, T1> _p1;
            private readonly Parser<TToken, T2> _p2;
            private readonly Parser<TToken, T3> _p3;
            private readonly Parser<TToken, T4> _p4;
            private readonly Parser<TToken, T5> _p5;
            private readonly Parser<TToken, T6> _p6;

            public Map6Parser(
                Func<T1, T2, T3, T4, T5, T6, R> func,
                Parser<TToken, T1> parser1,
                Parser<TToken, T2> parser2,
                Parser<TToken, T3> parser3,
                Parser<TToken, T4> parser4,
                Parser<TToken, T5> parser5,
                Parser<TToken, T6> parser6
            ) : base(ExpectedUtil.Concat(parser1.Expected, parser2.Expected, parser3.Expected, parser4.Expected, parser5.Expected, parser6.Expected))
            {
                _func = func;
                _p1 = parser1;
                _p2 = parser2;
                _p3 = parser3;
                _p4 = parser4;
                _p5 = parser5;
                _p6 = parser6;
            }

            internal sealed override Result<TToken, R> Parse(IParseState<TToken> state)
            {
                var consumedInput = false;

                
                var result1 = _p1.Parse(state);
                consumedInput = consumedInput || result1.ConsumedInput;
                if (!result1.Success)
                {
                    return Result.Failure<TToken, R>(
                        result1.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result2 = _p2.Parse(state);
                consumedInput = consumedInput || result2.ConsumedInput;
                if (!result2.Success)
                {
                    return Result.Failure<TToken, R>(
                        result2.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result3 = _p3.Parse(state);
                consumedInput = consumedInput || result3.ConsumedInput;
                if (!result3.Success)
                {
                    return Result.Failure<TToken, R>(
                        result3.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result4 = _p4.Parse(state);
                consumedInput = consumedInput || result4.ConsumedInput;
                if (!result4.Success)
                {
                    return Result.Failure<TToken, R>(
                        result4.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result5 = _p5.Parse(state);
                consumedInput = consumedInput || result5.ConsumedInput;
                if (!result5.Success)
                {
                    return Result.Failure<TToken, R>(
                        result5.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result6 = _p6.Parse(state);
                consumedInput = consumedInput || result6.ConsumedInput;
                if (!result6.Success)
                {
                    return Result.Failure<TToken, R>(
                        result6.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                return Result.Success<TToken, R>(_func(
                    result1.GetValueOrDefault(),
                    result2.GetValueOrDefault(),
                    result3.GetValueOrDefault(),
                    result4.GetValueOrDefault(),
                    result5.GetValueOrDefault(),
                    result6.GetValueOrDefault()
                ), consumedInput);
            }
        }

        /// <summary>
        /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
        /// </summary>
        /// <param name="func">A function to apply to the return values of the specified parsers</param>
        /// <param name="parser1">The first parser</param>
        /// <param name="parser2">The second parser</param>
        /// <param name="parser3">The third parser</param>
        /// <param name="parser4">The fourth parser</param>
        /// <param name="parser5">The fifth parser</param>
        /// <param name="parser6">The sixth parser</param>
        /// <param name="parser7">The seventh parser</param>
        /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
        /// <typeparam name="T1">The return type of the first parser</typeparam>
        ///<typeparam name="T2">The return type of the second parser</typeparam>
        ///<typeparam name="T3">The return type of the third parser</typeparam>
        ///<typeparam name="T4">The return type of the fourth parser</typeparam>
        ///<typeparam name="T5">The return type of the fifth parser</typeparam>
        ///<typeparam name="T6">The return type of the sixth parser</typeparam>
        ///<typeparam name="T7">The return type of the seventh parser</typeparam>
        /// <typeparam name="R">The return type of the resulting parser</typeparam>
        public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, T5, T6, T7, R>(
            Func<T1, T2, T3, T4, T5, T6, T7, R> func,
            Parser<TToken, T1> parser1,
            Parser<TToken, T2> parser2,
            Parser<TToken, T3> parser3,
            Parser<TToken, T4> parser4,
            Parser<TToken, T5> parser5,
            Parser<TToken, T6> parser6,
            Parser<TToken, T7> parser7
        ) => new Map7Parser<TToken, T1, T2, T3, T4, T5, T6, T7, R>(func, parser1, parser2, parser3, parser4, parser5, parser6, parser7);
        
        private sealed class Map7Parser<TToken, T1, T2, T3, T4, T5, T6, T7, R> : Parser<TToken, R>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, R> _func;
            private readonly Parser<TToken, T1> _p1;
            private readonly Parser<TToken, T2> _p2;
            private readonly Parser<TToken, T3> _p3;
            private readonly Parser<TToken, T4> _p4;
            private readonly Parser<TToken, T5> _p5;
            private readonly Parser<TToken, T6> _p6;
            private readonly Parser<TToken, T7> _p7;

            public Map7Parser(
                Func<T1, T2, T3, T4, T5, T6, T7, R> func,
                Parser<TToken, T1> parser1,
                Parser<TToken, T2> parser2,
                Parser<TToken, T3> parser3,
                Parser<TToken, T4> parser4,
                Parser<TToken, T5> parser5,
                Parser<TToken, T6> parser6,
                Parser<TToken, T7> parser7
            ) : base(ExpectedUtil.Concat(parser1.Expected, parser2.Expected, parser3.Expected, parser4.Expected, parser5.Expected, parser6.Expected, parser7.Expected))
            {
                _func = func;
                _p1 = parser1;
                _p2 = parser2;
                _p3 = parser3;
                _p4 = parser4;
                _p5 = parser5;
                _p6 = parser6;
                _p7 = parser7;
            }

            internal sealed override Result<TToken, R> Parse(IParseState<TToken> state)
            {
                var consumedInput = false;

                
                var result1 = _p1.Parse(state);
                consumedInput = consumedInput || result1.ConsumedInput;
                if (!result1.Success)
                {
                    return Result.Failure<TToken, R>(
                        result1.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result2 = _p2.Parse(state);
                consumedInput = consumedInput || result2.ConsumedInput;
                if (!result2.Success)
                {
                    return Result.Failure<TToken, R>(
                        result2.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result3 = _p3.Parse(state);
                consumedInput = consumedInput || result3.ConsumedInput;
                if (!result3.Success)
                {
                    return Result.Failure<TToken, R>(
                        result3.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result4 = _p4.Parse(state);
                consumedInput = consumedInput || result4.ConsumedInput;
                if (!result4.Success)
                {
                    return Result.Failure<TToken, R>(
                        result4.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result5 = _p5.Parse(state);
                consumedInput = consumedInput || result5.ConsumedInput;
                if (!result5.Success)
                {
                    return Result.Failure<TToken, R>(
                        result5.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result6 = _p6.Parse(state);
                consumedInput = consumedInput || result6.ConsumedInput;
                if (!result6.Success)
                {
                    return Result.Failure<TToken, R>(
                        result6.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result7 = _p7.Parse(state);
                consumedInput = consumedInput || result7.ConsumedInput;
                if (!result7.Success)
                {
                    return Result.Failure<TToken, R>(
                        result7.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                return Result.Success<TToken, R>(_func(
                    result1.GetValueOrDefault(),
                    result2.GetValueOrDefault(),
                    result3.GetValueOrDefault(),
                    result4.GetValueOrDefault(),
                    result5.GetValueOrDefault(),
                    result6.GetValueOrDefault(),
                    result7.GetValueOrDefault()
                ), consumedInput);
            }
        }

        /// <summary>
        /// Creates a parser that applies the specified parsers sequentially and applies the specified transformation function to their results.
        /// </summary>
        /// <param name="func">A function to apply to the return values of the specified parsers</param>
        /// <param name="parser1">The first parser</param>
        /// <param name="parser2">The second parser</param>
        /// <param name="parser3">The third parser</param>
        /// <param name="parser4">The fourth parser</param>
        /// <param name="parser5">The fifth parser</param>
        /// <param name="parser6">The sixth parser</param>
        /// <param name="parser7">The seventh parser</param>
        /// <param name="parser8">The eighth parser</param>
        /// <typeparam name="TToken">The type of tokens in the parser's input stream</typeparam>
        /// <typeparam name="T1">The return type of the first parser</typeparam>
        ///<typeparam name="T2">The return type of the second parser</typeparam>
        ///<typeparam name="T3">The return type of the third parser</typeparam>
        ///<typeparam name="T4">The return type of the fourth parser</typeparam>
        ///<typeparam name="T5">The return type of the fifth parser</typeparam>
        ///<typeparam name="T6">The return type of the sixth parser</typeparam>
        ///<typeparam name="T7">The return type of the seventh parser</typeparam>
        ///<typeparam name="T8">The return type of the eighth parser</typeparam>
        /// <typeparam name="R">The return type of the resulting parser</typeparam>
        public static Parser<TToken, R> Map<TToken, T1, T2, T3, T4, T5, T6, T7, T8, R>(
            Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
            Parser<TToken, T1> parser1,
            Parser<TToken, T2> parser2,
            Parser<TToken, T3> parser3,
            Parser<TToken, T4> parser4,
            Parser<TToken, T5> parser5,
            Parser<TToken, T6> parser6,
            Parser<TToken, T7> parser7,
            Parser<TToken, T8> parser8
        ) => new Map8Parser<TToken, T1, T2, T3, T4, T5, T6, T7, T8, R>(func, parser1, parser2, parser3, parser4, parser5, parser6, parser7, parser8);
        
        private sealed class Map8Parser<TToken, T1, T2, T3, T4, T5, T6, T7, T8, R> : Parser<TToken, R>
        {
            private readonly Func<T1, T2, T3, T4, T5, T6, T7, T8, R> _func;
            private readonly Parser<TToken, T1> _p1;
            private readonly Parser<TToken, T2> _p2;
            private readonly Parser<TToken, T3> _p3;
            private readonly Parser<TToken, T4> _p4;
            private readonly Parser<TToken, T5> _p5;
            private readonly Parser<TToken, T6> _p6;
            private readonly Parser<TToken, T7> _p7;
            private readonly Parser<TToken, T8> _p8;

            public Map8Parser(
                Func<T1, T2, T3, T4, T5, T6, T7, T8, R> func,
                Parser<TToken, T1> parser1,
                Parser<TToken, T2> parser2,
                Parser<TToken, T3> parser3,
                Parser<TToken, T4> parser4,
                Parser<TToken, T5> parser5,
                Parser<TToken, T6> parser6,
                Parser<TToken, T7> parser7,
                Parser<TToken, T8> parser8
            ) : base(ExpectedUtil.Concat(parser1.Expected, parser2.Expected, parser3.Expected, parser4.Expected, parser5.Expected, parser6.Expected, parser7.Expected, parser8.Expected))
            {
                _func = func;
                _p1 = parser1;
                _p2 = parser2;
                _p3 = parser3;
                _p4 = parser4;
                _p5 = parser5;
                _p6 = parser6;
                _p7 = parser7;
                _p8 = parser8;
            }

            internal sealed override Result<TToken, R> Parse(IParseState<TToken> state)
            {
                var consumedInput = false;

                
                var result1 = _p1.Parse(state);
                consumedInput = consumedInput || result1.ConsumedInput;
                if (!result1.Success)
                {
                    return Result.Failure<TToken, R>(
                        result1.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result2 = _p2.Parse(state);
                consumedInput = consumedInput || result2.ConsumedInput;
                if (!result2.Success)
                {
                    return Result.Failure<TToken, R>(
                        result2.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result3 = _p3.Parse(state);
                consumedInput = consumedInput || result3.ConsumedInput;
                if (!result3.Success)
                {
                    return Result.Failure<TToken, R>(
                        result3.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result4 = _p4.Parse(state);
                consumedInput = consumedInput || result4.ConsumedInput;
                if (!result4.Success)
                {
                    return Result.Failure<TToken, R>(
                        result4.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result5 = _p5.Parse(state);
                consumedInput = consumedInput || result5.ConsumedInput;
                if (!result5.Success)
                {
                    return Result.Failure<TToken, R>(
                        result5.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result6 = _p6.Parse(state);
                consumedInput = consumedInput || result6.ConsumedInput;
                if (!result6.Success)
                {
                    return Result.Failure<TToken, R>(
                        result6.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result7 = _p7.Parse(state);
                consumedInput = consumedInput || result7.ConsumedInput;
                if (!result7.Success)
                {
                    return Result.Failure<TToken, R>(
                        result7.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                var result8 = _p8.Parse(state);
                consumedInput = consumedInput || result8.ConsumedInput;
                if (!result8.Success)
                {
                    return Result.Failure<TToken, R>(
                        result8.Error.WithExpected(Expected),
                        consumedInput
                    );
                }

                return Result.Success<TToken, R>(_func(
                    result1.GetValueOrDefault(),
                    result2.GetValueOrDefault(),
                    result3.GetValueOrDefault(),
                    result4.GetValueOrDefault(),
                    result5.GetValueOrDefault(),
                    result6.GetValueOrDefault(),
                    result7.GetValueOrDefault(),
                    result8.GetValueOrDefault()
                ), consumedInput);
            }
        }
#endregion
    }
}

